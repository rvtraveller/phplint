<?php

namespace it\icosaedro\lint\documentator;

require_once __DIR__ . "/../../../../all.php";

use it\icosaedro\lint\Globals;
use it\icosaedro\lint\Visibility;
use it\icosaedro\lint\Constant;
use it\icosaedro\lint\Variable;
use it\icosaedro\lint\Function_;
use it\icosaedro\lint\Package;
use it\icosaedro\lint\Signature;
use it\icosaedro\lint\FormalArgument;
use it\icosaedro\lint\Result;
use it\icosaedro\lint\types\Type;
use it\icosaedro\lint\types\IntType;
use it\icosaedro\lint\types\StringType;
use it\icosaedro\lint\types\ArrayType;
use it\icosaedro\lint\types\ClassType;
use it\icosaedro\lint\types\ParameterType;
use it\icosaedro\lint\types\ClassConstant;
use it\icosaedro\lint\types\ClassProperty;
use it\icosaedro\lint\types\ClassMethod;
use it\icosaedro\io\IOException;
use it\icosaedro\io\File;
use it\icosaedro\io\FileOutputStream;
use it\icosaedro\utils\UString;
use it\icosaedro\utils\Strings;
use it\icosaedro\lint\docblock\DocBlock;
use it\icosaedro\containers\Arrays;
use it\icosaedro\containers\HashSet;

/**
 * Generates the HTML document for a specified package. A "package", in PHPLint,
 * is any PHP source file. The generated document lists the following items:
 * constants, global variables, functions, classes, class constants, properties,
 * methods. Private items are listed without further details. References to
 * functions, classes and methods external to the package are built as relative
 * paths to their HTML document. The HTML file is created in the same directory
 * of its PHP source.
 * <p>
 * <b>Usage.</b> Once an object of this class has been created, then the method
 * <code>parseCommandLine()</code> should be called for any command line
 * argument whose name begins with <code>--doc</code>.
 * The <code>--doc</code> literal argument enables the generator, so that the
 * <code>generate()</code> actually writes the HTML file (otherwise it does
 * nothing).
 * @author Umberto Salsi <salsi@icosaedro.it>
 * @version $Date: 2016/03/07 10:38:44 $
 */
class Documentator {
	
	/**
	 * Context of the parser.
	 * @var Globals 
	 */
	private $globals;
	
	/**
	 * Enables the <code>generate($fn)</code> method to actually generate the
	 * HTML document for package $fn. Set by the <code>--doc</code> command line
	 * option.
	 */
	private $do_generate = FALSE;
	
	/**
	 * Extension for the HTML file.
	 */
	private $extension = ".html";
	
	/**
	 * Header of each generated HTML file.
	 */
	private $page_header = "<HTML><BODY>\n";
	
	/**
	 * Footer for each generated HTML page.
	 */
	private $page_footer = ""; // initialized by __construct()
	
	/**
	 * Reference remapping. There is an even number of entries; for every pair,
	 * the first entry is the target and the second entry is the replacement.
	 * Every target is compared with the beginning of every link generated:
	 * if it match, that beginning of the link is replaced.
	 */
	private $ref_remap = /*. (string[int]) .*/ array();
	
	/**
	 * Package we are documenting right now.
	 * @var File 
	 */
	private $fn;
	
	/**
	 * HTML file currently open.
	 * @var FileOutputStream 
	 */
	private $html;
	
	/**
	 * @var RelativePathBuilder
	 */
	private $relative_path;
	
	/**
	 * In-line tags resolver.
	 * @var InLineTags 
	 */
	private $in_line_tags;
	
	
	/*
	 * Private items are not shown in detail, but are listed at the bottom of
	 * the file (private global items) or of the class (private class items).
	 * The following properties are filled-in while collecting items that need
	 * to be reported in full details.
	 */
	
	
	/**
	 * Private constants.
	 * @var Constant[int] 
	 */
	private $private_constants;
	
	
	/**
	 * Private global variables.
	 * @var Variable[int] 
	 */
	private $private_variables;
	
	
	/**
	 * Private functions.
	 * @var Function_[int] 
	 */
	private $private_functions;
	
	
	/**
	 * Private classes.
	 * @var ClassType[int] 
	 */
	private $private_classes;
	
	
	/**
	 * Private class constants collected from current class being documented.
	 * @var ClassConstant[int] 
	 */
	private $private_class_constants;
	
	
	/**
	 * Private properties collected from current class being documented.
	 * @var ClassProperty[int] 
	 */
	private $private_properties;
	
	
	/**
	 * Private methods collected from current class being documented.
	 * @var ClassMethod[int] 
	 */
	private $private_methods;
	

	/**
	 * Creates a document generator initially disabled.
	 * By "disabled" here it means the <code>generate()</code> does nothing.
	 * @param Globals $globals
	 * @return void 
	 */
	public function __construct($globals) {
		$this->globals = $globals;
		$this->page_footer = "\n<HR><P align=right>"
		. "<FONT size='-2'>Generated by "
		. "<a href='http://www.icosaedro.it/phplint/'>PHPLint Documentator</a>"
		. "</FONT></P>\n"
		. "</BODY></HTML>\n";
	}

	
	private function help(){
		$this->globals->logger->printVerbatim(
"PHPLint Documentator\n\n" .
"Options:\n" .
"  --doc                 enable documentation generator\n" .
"  --doc-extension EXT   extension of the generated documents (def. \".html\")\n" .
"  --doc-page-header H   header text of the generated HTML page\n" .
"  --doc-page-footer F   footer text of the generated HTML page\n" .
"  --doc-ref-remap A B   remap HTML anchors references from A* to B*\n" .
"\n"
	);
	}
	

	/**
	 * Parses command line arguments related to this class.
	 * @param int $i Index to the current command line option. This option
	 * MUST be one of the Documentator options that starts with "--doc".
	 * @param string[int] $args_ Command line arguments.
	 * @return int Index to the next command line argument not consumed.
	 */
	public function parseCommandLine($i, $args_) {
		$logger = $this->globals->logger;
		switch($args_[$i]){
			
		case "--doc-help":
			$this->help();
			break;
		
		case "--doc":
			$this->do_generate = TRUE;
			break;
		
		case "--doc-extension":
			$i++;
			if( $i >= count($args_) )
				$logger->error(NULL,
				"phplint: missing argument for --doc-extension\n");
			else
				$this->extension = $args_[$i];
			break;
			
		case "--doc-page-header":
			$i++;
			if( $i >= count($args_) )
				$logger->error(NULL,
				"phplint: missing argument for --doc-page-header\n");
			else
				$this->page_header = $args_[$i];
			break;
		
		case "--doc-page-footer":
			$i++;
			if( $i >= count($args_) )
				$logger->error(NULL,
				"phplint: missing argument for --doc-page-footer\n");
			else
				$this->page_footer = $args_[$i];
			break;
			
		case "--doc-ref-remap":
			if( $i+2 >= count($args_) )
				$logger->error(NULL,
				"phplint: more args required for --doc-ref-remap");
			else {
				$this->ref_remap[] = $args_[$i+1];
				$this->ref_remap[] = $args_[$i+2];
				$i += 2;
			}
			break;
			
		default:
			$logger->error(NULL, "phplint: unknown option `". $args_[$i] ."'");
			$i++;
		}
		return $i + 1;
	}
	
	
	/**
	 * 
	 * @param string $s
	 * return string
	 */
	private static function escapeHtml($s){
		$s = (string) str_replace("&", "&amp;", $s);
		$s = (string) str_replace("<", "&lt;", $s);
		$s = (string) str_replace(">", "&gt;", $s);
		return $s;
	}
	
	
	/**
	 * @param string $s
	 * @throws IOException 
	 */
	private function write($s){
		$this->html->writeBytes($s);
	}

	
	/**
	 * Writes an HTML link to some class.
	 * @param ClassType $c Class to be reported and linked.
	 * @throws IOException 
	 */
	private function writeClassType($c){
		if( $c === ClassType::getObject() ){
			$this->write("object");
			return;
		}
		if( $c->is_anonymous ){
			// Anonymous class. Displays its mangled name.
			// Should never appear in the document anyway.
			$fqn = $c->name->__toString();
			$this->write(htmlspecialchars($fqn));
			
		} else if( $c instanceof ParameterType ){
			// Formal type on a template.
			// Displays the short name and a reference to the template.
			$parameter = cast(ParameterType::class, $c);
			$template = $parameter->template;
			$fqn = $template->name->__toString();
			$fragment = HtmlUtils::escapeFragment($fqn);
			$href = $this->relative_path->build($template->decl_in->getFile());
			$name_escaped = htmlspecialchars($parameter->short_name);
			$this->write("<a href='$href#$fragment' title='$fqn'>$name_escaped</a>");
			
		} else if( $c->is_wildcard ){
			// Class wildcard "?".
			if( $c->superclassOf !== NULL ){
				$this->write("? parent ");
				$this->writeClassType($c->superclassOf);
			} else {
				if( count($c->implemented) > 0 )
					$bound = $c->implemented[0];
				else
					$bound = $c->extended;
				if( $bound !== ClassType::getObject() ){
					$this->write("? extends ");
					$this->writeClassType($bound);
				} else {
					$this->write("?");
				}
			}
			
		} else {
			// Normal class.
			$fqn = $c->name->__toString();
			$fragment = HtmlUtils::escapeFragment($fqn);
			$href = $this->relative_path->build($c->decl_in->getFile());
			$name_escaped = htmlspecialchars($c->name->getName());
			if( $c->is_interface || $c->is_abstract || $c->is_unchecked )
				$name_escaped = "<i>$name_escaped</i>";
			$this->write("<a href='$href#$fragment' title='$fqn'>$name_escaped</a>");
		}
		
		// Normal classes and anonymous class may have type parameters.
		if( count($c->parameters_by_index) > 0 ){
			// Is generic, but not a formal parameter - show actual params:
			$this->write("&lt;");
			for($i = 0; $i < count($c->parameters_by_index); $i++){
				if( $i > 0 )
					$this->write(",");
				$this->writeClassType($c->parameters_by_index[$i]);
			}
			$this->write("&gt;");
		}
	}
	
	
	/*. forward private void function writeType(Type $t) throws IOException; .*/
	
	
	/**
	 * Writes an array type.
	 * @param ArrayType $a 
	 * @throws IOException 
	 */
	private function writeArrayType($a){
		$s = "";
		do {
			if( $a->getIndex() instanceof IntType )
				$s .= "[int]";
			else if( $a->getIndex() instanceof StringType )
				$s .= "[string]";
			else
				$s .= "[]";
			if( $a->getElem() instanceof ArrayType )
				$a = cast(ArrayType::class, $a->getElem());
			else {
				$this->writeType($a->getElem());
				$this->write($s);
				return;
			}
		} while(TRUE);
	}
	
	
	/**
	 * Writes a type.
	 * @param Type $t 
	 * @throws IOException 
	 */
	private function writeType($t){
		if( $t instanceof ClassType ){
			$this->writeClassType(cast(ClassType::class, $t));
		} else if( $t instanceof ArrayType ){
			$this->writeArrayType(cast(ArrayType::class, $t));
		} else {
			$this->write($t->__toString());
		}
	}
	
	
	/**
	 * Writes a value. Values retrieved by the parser are encoded in a PHP-like
	 * form with the only exception of the strings, where only the actual
	 * bytes of the string are save; then, strings must be properly quoted and
	 * special chars must be escaped.
	 * @param Result $r
	 * @throws IOException 
	 */
	private function writeValue($r){
		if( $r === NULL ){
			// Missing default value of unresolved 'forward' declaration can be NULL.
			$this->write("UNKNONW");
			return;
		}
		$type = $r->getType();
		$value = $r->getValue();
		if( $type instanceof StringType ){
			if( $value === "NULL" )
				// FIXME: what if the literal string is just "NULL"?
				// Unsatisfactory workaround; see also the comment about the
				// Result::$value property.
				$this->write("NULL");
			else
				$this->write( self::escapeHtml( Strings::toLiteral($value) ) );
		} else
			$this->write($value);
	}
	
	
	/**
	 * Returns true if at least one non-empty entry string is found in the
	 * array of strings.
	 * @param string[int] $a 
	 * @return boolean
	 */
	private static function nonEmptyEntryFound($a){
		if( $a === NULL || count($a) == 0 )
			return FALSE;
		for($i = count($a)-1; $i >= 0; $i--)
			if( strlen($a[$i]) > 0 )
				return TRUE;
		return FALSE;
	}
	
	
	/**
	 * Prints DocBlock. Only shows informations available that are not already
	 * present in the signature of a function. Resolves in-line tags "{@...}"
	 * in comments.
	 * @param DocBlock $db
	 * @param ClassType $contextual_class Class or class member to which this
	 * DocBlock belongs. Used to resolve some special forms notations of the
	 * in-line tags. Set to null if this DocBlock does not belongs to a class.
	 * @throws IOException 
	 */
	private function writeDocBlock($db, $contextual_class){
		if( $db === NULL ){
			return;
		}
		
		$where = $db->decl_in;
		$c = $contextual_class;
		
		$this->write("<p>\n" . $this->in_line_tags->resolve($where,
			$db->short_descr, $c) . "\n");
		$this->write($this->in_line_tags->resolve($where,
			$db->long_descr, $c) . "<br>\n");
		
		if( strlen($db->deprecated_descr) > 0 )
			$this->write("<b>Deprecated.</b>\n"
			. $this->in_line_tags->resolve($where, $db->deprecated_descr, $c)
			. "<br>\n");
		
		// Writes a "Parameters:" section only if at least a description exists:
		$nonEmptyDescrFound = FALSE;
		if( $db->params !== NULL )
			foreach($db->params as $p)
				if( strlen($p->descr) > 0 ){
					$nonEmptyDescrFound = TRUE;
					break;
				}
		if( $nonEmptyDescrFound ){
			$this->write("<b>Parameters:</b><br>\n");
			foreach($db->params as $p){
				if( strlen($p->descr) == 0 )
					continue;
				$this->write("<code>\$"
				. $p->name . "</code> - "
				. $this->in_line_tags->resolve($where,
					$p->descr, $c) . "<br>\n");
			}
		}
		
		if( strlen($db->return_descr) > 0 ){
			$this->write("<b>Return:</b> "
			. $this->in_line_tags->resolve($where, $db->return_descr, $c)
			. "<br>\n");
		}
		
		if( self::nonEmptyEntryFound($db->triggers_descrs) ){
			$this->write("<b>Triggers:</b><br>\n");
			for($i = 0; $i < count($db->triggers_names); $i++){
				if( strlen($db->triggers_descrs[$i]) == 0 )
					continue;
				$this->write("<code>"
				.$db->triggers_names[$i] ."</code> - "
				. $this->in_line_tags->resolve($where, $db->triggers_descrs[$i], $c)
				. "<br>\n");
			}
		}
		
		if( self::nonEmptyEntryFound($db->throws_descrs) ){
			$this->write("<b>Throws:</b><br>\n");
			for($i = 0; $i < count($db->throws_exceptions); $i++){
				if( strlen($db->throws_descrs[$i]) == 0 )
					continue;
				$this->write("<code>");
				$this->writeType($db->throws_exceptions[$i]);
				$this->write("</code> - "
				. $this->in_line_tags->resolve($where, $db->throws_descrs[$i], $c)
				. "<br>\n");
			}
		}
		
		// FIXME: the other line-tags are rendered as text, no HTML and no
		// in-line tag resolution.
		for($i = 0; $i < count($db->others); $i += 2){
			$tag = ucfirst( substr($db->others[$i], 1) );
			$this->write("<b>" . $tag
			. "</b>: " . self::escapeHtml($db->others[$i+1]) . "<br>\n");
		}
	}
	
	
	/**
	 * Writes a general description of the package.
	 * @throws IOException 
	 */
	private function docHeader(){
		$pkg = $this->globals->getPackage($this->fn);
		$db = $pkg->docblock;
		
		$title = "";
		if( $db === NULL || $db->package_word === "" ){
			$title = $this->fn->getName()->toUTF8(); // FIXME: locale encoded
		} else {
			$title = $db->package_word;
		}
		$this->write("<h1>" . self::escapeHtml($title) . "</h1>\n");
		
		$this->writeDocBlock($db, NULL);
	}
	
	
	/**
	 * @throws IOException
	 */
	private function docFooter(){
		$this->write("<hr><h2>Requirements</h2>\n");
		
		$php_ver = $this->globals->php_ver->__toString();
		$this->write("<p><b>PHP Version:</b> $php_ver\n");
		
		$this->write("<p><b>Required modules:</b>\n");
		$modules = /*. (File[int]) .*/ array();
		foreach($this->globals->packages as $mp){
			$p = cast("it\\icosaedro\\lint\\Package", $mp);
			if( $p->is_module && ! $p->fn->equals($this->fn) )
				$modules[] = $p->fn;
		}
		$modules = cast("it\\icosaedro\\io\\File[int]", Arrays::sort($modules));
		if( count($modules) == 0 )
			$this->write("<i>none</i>");
		for($i = 0; $i < count($modules); $i++){
			if( $i > 0 )  $this->write(",\n");
			$name = basename($modules[$i]->getName()->toASCII(), ".php");
			$this->write("<code>$name</code>");
		}
		
		$this->write("<p><b>Required packages:</b>\n");
		$packages = /*. (Package[int]) .*/ array();
		foreach($this->globals->packages as $mp){
			$p = cast("it\\icosaedro\\lint\\Package", $mp);
			if( ! $p->is_module && ! $p->fn->equals($this->fn) )
				$packages[] = $p;
		}
		$packages = cast("it\\icosaedro\\lint\\Package[int]", Arrays::sort($packages));
		if( count($packages) == 0 )
			$this->write("<i>none</i>");
		// The list of packages may become very long; in this case use
		// a box with scroll bar:
		$use_scrollbox = count($packages) > 20;
		if( $use_scrollbox ){
			$this->write("<div style='height:10em; width:100%; border:1px solid #ccc; overflow:auto;'>");
		}
		for($i = 0; $i < count($packages); $i++){
			if( $i > 0 ){
				if( $use_scrollbox )
					$this->write("<br>\n");
				else
					$this->write(",\n");
			}
			$p = $packages[$i];
			$href = $this->relative_path->build($p->fn);
			$slash = strrpos($href, "/");
			if( $slash === FALSE )
				$path = "";
			else
				$path = substr($href, 0, $slash+1);
			$text = $p->fn->getName()->toASCII();
			$this->write("<code>$path<a href='$href'>$text</a></code>");
		}
		if( $use_scrollbox )
			$this->write("</div>\n");
	}
	
	
	/**
	 * Writes all the non-private constants. Also collects the private
	 * constants, so that them can be listed next.
	 * @throws IOException 
	 */
	private function docConstants(){
		$cs = /*. (Constant[int]) .*/ array();
		foreach($this->globals->constants as $mc){
			$c = cast(Constant::class, $mc);
			if( $c->decl_in->getFile() === $this->fn ){
				if( $c->is_private )
					$this->private_constants[] = $c;
				else
					$cs[] = $c;
			}
		}
		if( count($cs) == 0 )
			return;
		$this->write("<h2>Constants</h2>\n");
		$cs = cast(Constant::class . "[int]", Arrays::sort($cs));
		foreach($cs as $c){
			$fqn = $c->name->__toString();
			$name = $c->name->getName();
			$fragment = HtmlUtils::escapeFragment($fqn);
			$this->write("<hr><a name='$fragment'><h3>$name</h3></a>\n");
			$this->write("<code><a title='$fqn'><b>$name</b></a> = ");
			$this->writeValue($c->value);
			$this->write("</code><br>\n");
			$this->writeDocBlock($c->docblock, NULL);
		}
	}
	
	
	/**
	 * Writes all the non-private globals variables. Also collects all the
	 * private global variables, so that them can be listed next.
	 * @throws IOException 
	 */
	private function docVariables(){
		$vs = /*. (Variable[int]) .*/ array();
		for($i = $this->globals->vars_n - 1; $i >= 0; $i--){
			$v = $this->globals->vars[$i];
			if( $v !== NULL && $v->decl_in->getFile() === $this->fn ){
				if( $v->is_private )
					$this->private_variables[] = $v;
				else
					$vs[] = $v;
			}
		}
		if( count($vs) == 0 )
			return;
		$this->write("<h2>Variables</h2>\n");
		$vs = cast(Variable::class."[int]", Arrays::sort($vs));
		foreach($vs as $v){
			$fragment = HtmlUtils::escapeFragment($v->__toString());
			$this->write("<hr><a name='$fragment'><h3>$v</h3></a>\n");
			$private_s = $v->is_private? "private " : "";
			$this->write("<code>$private_s");
			$this->writeType($v->type);
			$this->write(" <b>$v</b></code><br>\n");
			$this->writeDocBlock($v->docblock, NULL);
		}
	}
	
	
	/**
	 * Writes a formal argument.
	 * @param FormalArgument $a
	 * @throws IOException 
	 */
	private function writeFormalArgument($a){
		if( $a->reference_return )
			$this->write("return ");
		$this->writeType($a->type);
		$this->write(" ");
		if( $a->reference )
			$this->write("&amp; ");
		if( $a->is_variadic )
			$this->write("... ");
		$this->write("\$" . $a->name);
		if( ! $a->is_mandatory && ! $a->is_variadic ){
			$this->write(" = ");
			$this->writeValue($a->value);
		}
	}
	
	
	/**
	 * Wites the prototype of a function or method.
	 * @param string $name Name Trailing name of the function (without NS) or
	 * name of the method terminated by "()".
	 * @param string $title Value for the 'title' attribute. Shoud be the FQN
	 * of the function or FQN() of class followed by "::METHOD()".
	 * @param Signature $sign 
	 * @throws IOException 
	 */
	private function writePrototype($name, $title, $sign){
		
		$this->writeType($sign->returns);
		if( $sign->reference )
			$this->write(" &");
		$this->write(" <a title='$title'><b>$name</b></a>(");

		# Mandatory and default args:
		for($i = 0; $i < count($sign->arguments); $i++){
			if( $i > 0 )
				$this->write(", ");
			$this->writeFormalArgument($sign->arguments[$i]);
		}

		if( $sign->variadic !== NULL ){
			if( count($sign->arguments) > 0 )
				$this->write(", ");
			$this->writeFormalArgument($sign->variadic);
		}

		if( $sign->more_args ){
			if( count($sign->arguments) > 0 )
				$this->write(", ");
			$this->write("args");
		}
		
		$this->write(")");
		
		if( ! $sign->errors->isEmpty() )
			$this->write(" triggers " . $sign->errors);
		
		if( ! $sign->exceptions->isEmpty() ){
			$this->write(" throws ");
			$sign->exceptions;
			$es = cast(ClassType::class."[int]", $sign->exceptions->getElements());
			$es = cast(ClassType::class."[int]", Arrays::sort($es));
			for($i = 0; $i < count($es); $i++){
				if( $i > 0 )
					$this->write(", ");
				$this->writeType($es[$i]);
			}
		}
	}
	
	
	/**
	 * Writes a function.
	 * @param Function_ $f
	 * @throws IOException 
	 */
	private function docFunction($f){
		$fqn = $f->name->__toString() . "()";
		$name = $f->name->getName();
		$fragment = HtmlUtils::escapeFragment($fqn);
		$this->write("<hr><a name='$fragment'><h3>$name()</h3></a>\n");
		$private_s = $f->is_private? "private " : "";
		$this->write("<code>$private_s");
		$this->writePrototype($name, $fqn, $f->sign);
		$this->write("</code>\n");
		$this->writeDocBlock($f->docblock, NULL);
	}
	
	
	/**
	 * Writes all the non-private functions. Private functions are collected
	 * and listed next.
	 * @throws IOException 
	 */
	private function docFunctions(){
		$fs = /*. (Function_[int]) .*/ array();
		foreach($this->globals->functions as $mf){
			$f = cast(Function_::class, $mf);
			if( $f->decl_in->getFile() === $this->fn ){
				if( $f->is_private )
					$this->private_functions[] = $f;
				else
					$fs[] = $f;
			}
		}
		if( count($fs) == 0 )
			return;
		$this->write("<h2>Functions</h2>\n");
		$fs = cast(Function_::class."[int]", Arrays::sort($fs));
		foreach($fs as $f){
			$this->docFunction($f);
		}
	}

	
	/**
	 * @param ClassType $c
	 * @param string $indent_this
	 * @param string $indent_next
	 * @param boolean $anchor 
	 * @return void
	 * @throws IOException 
	 */
	private function docClassHierarchyRecurse($c, $indent_this, $indent_next, $anchor)
	{
		$this->write($indent_this);
		if( $anchor ){
			$this->writeType($c);
		}
		$this->write( "\n" );

		if( $c->extended !== NULL && $c->extended !== ClassType::getObject() ){
			if( $c->implemented === NULL ){
				$a = "  `--";
				$b = "     ";
			} else {
				$a = "  +--";
				$b = "  |  ";
			}
			$this->docClassHierarchyRecurse($c->extended, $indent_next . $a, $indent_next . $b, TRUE);
		}

		for( $i = 0; $i < count($c->implemented); $i++){
			if( $i == count($c->implemented)-1 ){
				$a = "  `--";
				$b = "     ";
			} else {
				$a = "  +--";
				$b = "  |  ";
			}
			$this->docClassHierarchyRecurse($c->implemented[$i], $indent_next . $a, $indent_next . $b, TRUE);
		}
	}


	/**
	 * @param ClassType $c
	 * @throws IOException 
	 */
	private function docClassHierarchy($c)
	{
		if( ($c->extended === NULL || $c->extended === ClassType::getObject())
		&& $c->implemented === NULL ){
			return;
		}
		$this->docClassHierarchyRecurse($c, "      |  ", "    ", FALSE);
	}

	
	
	/**
	 * Documents non-private class constants. Private class constants are
	 * collected to be listed next.
	 * @param ClassType $c
	 * @throws IOException 
	 */
	private function docClassConstants($c){
		if( count($c->constants) == 0 )
			return;
		$cs = /*. (ClassConstant[int]) .*/ array();
		foreach($c->constants as $co){
			if( $co->visibility === Visibility::$private_ )
				$this->private_class_constants[] = $co;
			else
				$cs[] = $co;
		}
		if( count($cs) == 0 )
			return;
		$this->write("<h2>Class constants</h2>\n");
		$cs = cast(ClassConstant::class."[int]", Arrays::sort($cs));
		foreach($cs as $co){
			$fragment = HtmlUtils::escapeFragment($co->__toString());
			$this->write("<hr><a name='$fragment'><h3>" . $co->name ."</h3></a>\n");
			$this->write("<code>" . $co->visibility . " <a title='$co'><b>"
			. $co->name . "</b></a> = ");
			$this->writeValue($co->value);
			$this->write("</code>\n");
			$this->writeDocBlock($co->docblock, $c);
		}
	}
	
	
	/**
	 * Documents non-private properties. Private properties are collected to be
	 * listed next.
	 * @param ClassType $c
	 * @throws IOException 
	 */
	private function docProperties($c){
		if( count($c->properties) == 0 )
			return;
		$ps = /*. (ClassProperty[int]) .*/ array();
		foreach($c->properties as $p){
			if( $p->visibility === Visibility::$private_ )
				$this->private_properties[] = $p;
			else
				$ps[] = $p;
		}
		if( count($ps) == 0 )
			return;
		$this->write("<h2>Properties</h2>\n");
		$ps = cast(ClassProperty::class."[int]", Arrays::sort($ps));
		foreach($ps as $p){
			$fragment = HtmlUtils::escapeFragment($p->__toString());
			$this->write("<hr><a name='$fragment'><h3>\$" . $p->name ."</h3></a>\n");
			$this->write("<code>" . $p->visibility . " "
			. ($p->is_static? "static " : ""));
			$this->writeType( $p->value->getType() );
			$this->write(" <b><a title='$p'>\$"
			. $p->name . "</a></b></code>\n");
			$this->writeDocBlock($p->docblock, $c);
		}
	}
	
	
	/**
	 * Lists overriden and implemented methods.
	 * @param ClassMethod $m
	 * @throws IOException 
	 */
	private function docOverridesImplements($m){
		if( $m->is_constructor || $m->is_destructor )
			// Ctor and dtor never override nor implement.
			return;
		if( $m->class_->extended !== NULL ){
			$m2 = $m->class_->extended->searchMethod($m->name);
			if( $m2 !== NULL ){
				if( ! $m->is_abstract && $m2->is_abstract )
					$this->write("<br>Implements <code>");
				else
					$this->write("<br>Overrides <code>");
					$this->writeClassType($m2->class_);
					$fragment = HtmlUtils::escapeFragment("$m2()");
					$href = $this->relative_path->build($m2->decl_in->getFile())
					 . "#$fragment";
					$this->write("::<a href='$href'>" . $m2->name ."()</a>");
					$this->write("</code>\n");
			}
		}
		if( count($m->class_->implemented) > 0 ){
			// Might override/implement methods inherited from several
			// classes and interfaces: need a set to remove duplicates:
			$methods = new HashSet();
			foreach($m->class_->implemented as $impl){
				$m2 = $impl->searchMethod($m->name);
				if( $m2 !== NULL ){
					$methods->put($m2);
				}
			}
			foreach($methods as $m2_){
				$m2 = cast(ClassMethod::class, $m2_);
				if( ! $m->is_abstract && $m2->is_abstract )
					$this->write("<br>Implements <code>");
				else
					$this->write("<br>Overrides <code>");
				$this->writeClassType($m2->class_);
				$fragment = HtmlUtils::escapeFragment("$m2()");
				$href = $this->relative_path->build($m2->decl_in->getFile())
				 . "#$fragment";
				$this->write("::<a href='$href'>" . $m2->name ."()</a>");
				$this->write("</code>\n");
			}
		}
	}
	
	
	/**
	 * Writes a method.
	 * @param ClassMethod $m
	 * @throws IOException 
	 */
	private function docMethod($m){
		$long = $m->__toString() . "()";
		$short = $m->name->__toString();
		$fragment = HtmlUtils::escapeFragment($long);
		$this->write("<hr><a name='$fragment'><h3>$short()</h3></a>\n");
		$this->write("<code>" . $m->visibility . " ");
		if( $m->is_abstract && ! $m->class_->is_interface )
			$this->write("abstract ");
		if( $m->is_static )
			$this->write("static ");
		if( $m->is_final )
			$this->write("final ");
		$this->writePrototype($short, $long, $m->sign);
		$this->write("</code>\n");
		$this->docOverridesImplements($m);
		$this->writeDocBlock($m->docblock, $m->class_);
	}
	
	
	/**
	 * Documents non-private methods. Private methods are collected to be
	 * listed next.
	 * @param ClassType $c
	 * @throws IOException 
	 */
	private function docMethods($c){
		// Methods to be reported:
		$ms = /*. (ClassMethod[int]) .*/ array();
		
		$ctor = $c->constructor;
		if( $ctor === NULL )
			$ctor = $c->parentConstructor();
		if( $ctor !== NULL && $ctor->visibility === Visibility::$private_ )
			$ctor = NULL;
		
		foreach($c->methods as $mm){
			$m = cast(ClassMethod::class, $mm);
			if( $m->visibility === Visibility::$private_ )
				$this->private_methods[] = $m;
			else
				$ms[] = $m;
		}
		
		if( count($ms) == 0 && $ctor === NULL )
			return;
		
		$this->write("<h2>Methods</h2>\n");
		if( $ctor !== NULL
		&& $ctor->visibility !== Visibility::$private_ )
			$this->docMethod($ctor);
		
		if( $c->destructor !== NULL
		&& $c->destructor->visibility !== Visibility::$private_ )
			$this->docMethod($c->destructor);
		
		$ms = cast(ClassMethod::class."[int]", Arrays::sort($ms));
		foreach($ms as $m){
			if( !( $m === $c->constructor || $m === $c->destructor ) )
				$this->docMethod($m);
		}
	}
	
	
	/**
	 * Lists all the inherited non-private members of the class.
	 * @param ClassType $c
	 * @throws IOException 
	 */
	private function docInherited($c)
	{
		$cs = Inheritance::inheritedConstants($c);
		if( count($cs) > 0 ){
			$this->write("<hr><b>Inherited constants:</b>\n");
			for($i = 0; $i < count($cs); $i++){
				if( $i > 0 )  $this->write(",\n");
				$co = $cs[$i];
				$fragment = HtmlUtils::escapeFragment("$co");
				$href = $this->relative_path->build($co->decl_in->getFile())
				 . "#$fragment";
				$this->write("<a href='$href'><code>" . $co->name
				."</code></a>");
			}
		}
		
		$ps = Inheritance::inheritedProperties($c);
		if( count($ps) > 0 ){
			$this->write("<hr><b>Inherited properties:</b>\n");
			for($i = 0; $i < count($ps); $i++){
				if( $i > 0 )  $this->write(",\n");
				$p = $ps[$i];
				$fragment = HtmlUtils::escapeFragment("$p");
				$href = $this->relative_path->build($p->decl_in->getFile())
				 . "#$fragment";
				$this->write("<a href='$href'><code>\$" . $p->name
				."</code></a>");
			}
		}
		
		$ms = Inheritance::inheritedMethods($c);
		if( count($ms) > 0 ){
			$this->write("<hr><b>Inherited methods:</b>\n");
			for($i = 0; $i < count($ms); $i++){
				if( $i > 0 )  $this->write(",\n");
				$m = $ms[$i];
				$fragment = HtmlUtils::escapeFragment("$m()");
				$href = $this->relative_path->build($m->decl_in->getFile())
				 . "#$fragment";
				$this->write("<a href='$href'><code>" . $m->name
				."()</code></a>");
			}
		}
	}
	
	
	/**
	 * Lists all the private member of the class, without details. These
	 * members were already collected while reporting the non-private ones,
	 * and are available under some properties of this object; that's why this
	 * method has not a class as parameter.
	 * @throws IOException 
	 */
	private function docClassPrivateMembers(){
		
		if( count($this->private_class_constants) > 0 ){
			$this->write("<hr>\n");
			$cs = cast(ClassConstant::class."[int]",
				Arrays::sort($this->private_class_constants));
			$this->write("<b>Private constants:</b>\n");
			for($i = 0; $i < count($cs); $i++){
				if( $i > 0 )  $this->write(",\n");
				$this->write("<code>" . $cs[$i]->name . "</code>");
			}
			$this->write("<br>\n");
			$this->private_class_constants = NULL;
		}
		
		if( count($this->private_properties) > 0 ){
			$this->write("<hr>\n");
			$ps = cast(ClassProperty::class."[int]",
				Arrays::sort($this->private_properties));
			$this->write("<b>Private properties:</b>\n");
			for($i = 0; $i < count($ps); $i++){
				if( $i > 0 )  $this->write(",\n");
				$this->write("<code>\$" . $ps[$i]->name . "</code>");
			}
			$this->write("<br>\n");
			$this->private_properties = NULL;
		}
		
		if( count($this->private_methods) > 0 ){
			$this->write("<hr>\n");
			$ms = cast(ClassMethod::class."[int]",
				Arrays::sort($this->private_methods));
			$this->write("<b>Private methods:</b>\n");
			for($i = 0; $i < count($ms); $i++){
				if( $i > 0 )  $this->write(",\n");
				$this->write("<code>" . $ms[$i]->name . "()</code>");
			}
			$this->write("<br>\n");
			$this->private_methods = NULL;
		}
	}
	
	
	/**
	 * Writes a class.
	 * @param ClassType $c
	 * @throws IOException 
	 */
	private function docClass($c){
		$this->private_class_constants = /*. (ClassConstant[int]) .*/ array();
		$this->private_properties = /*. (ClassProperty[int]) .*/ array();
		$this->private_methods = /*. (ClassMethod[int]) .*/ array();
		$long = $c->name->__toString();
		$short = $c->name->getName();
		$this->write("<hr><a name='$long'><h3>$short</h3></a>\n");
		$this->write("<pre>");
		if( $c->is_private )
			$this->write("private ");
		if( $c->is_unchecked )
			$this->write("unchecked ");
		if( $c->is_interface )
			$this->write("interface ");
		else if( $c->is_abstract )
			$this->write("abstract class ");
		else {
			if( $c->is_final )
				$this->write("final ");
			$this->write("class ");
		}
		$this->write("<a title='$long'><b>$short</b></a>");
		
		// Template's parameters:
		if( $c->is_template ){
			$this->write("&lt;");
			for($i = 0; $i < count($c->parameters_by_index); $i++){
				if( $i > 0 )
					$this->write(", ");
				$parameter = cast(ParameterType::class, $c->parameters_by_index[$i]);
				$this->write(htmlspecialchars($parameter->short_name));
				$bounds = $parameter->getBounds();
				if( count($bounds) > 0 ){
					$this->write(" extends ");
					for($j = 0; $j < count($bounds); $j++){
						if( $j > 0 )
							$this->write(" &amp; ");
						$this->writeClassType($bounds[$j]);
					}
				}
			}
			$this->write("&gt;");
		}
		
//		if( $c->extended !== NULL
//		&& $c->extended !== ClassType::getObject() ){
//			$this->write(" extends ");
//			$this->writeType($c->extended);
//		}
//		if( $c->implemented !== NULL ){
//			if( $c->is_interface )
//				$this->write(" extends");
//			else
//				$this->write(" implements");
//			$first = TRUE;
//			foreach($c->implemented as $iface){
//				if( $first )
//					$this->write(" ");
//				else
//					$this->write(", ");
//				$first = FALSE;
//				$this->writeType($iface);
//			}
//		}
		$this->write("\n");
		$this->docClassHierarchy($c);
		$this->write("\n{</pre>\n");
		$this->write("<blockquote>\n");
		$this->writeDocBlock($c->docblock, $c);
		$this->docClassConstants($c);
		$this->docProperties($c);
		$this->docMethods($c);
		$this->docInherited($c);
		$this->docClassPrivateMembers();
		$this->write("</blockquote>\n");
		$this->write("<code>}</code>\n");
	}
	
	
	/**
	 * Writes all the classes defined in the current package.
	 * @throws IOException 
	 */
	private function docClasses(){
		$cs = /*. (ClassType[int]) .*/ array();
		foreach($this->globals->classes as $mc){
			$c = cast(ClassType::class, $mc);
			if( $c->decl_in->getFile() === $this->fn ){
				if( $c->is_anonymous ){
					// anonymous classes never reported
				} else if( $c->is_private ){
					// private classes listed -- their name "pollutes" the NS
					$this->private_classes[] = $c;
				} else {
					// class to fully report
					$cs[] = $c;
				}
			}
		}
		if( count($cs) == 0 )
			return;
		$this->write("<h2>Classes</h2>\n");
		$cs = cast(ClassType::class."[int]", Arrays::sort($cs));
		foreach($cs as $c){
			$this->docClass($c);
		}
	}
	
	
	/**
	 * Lists all the private global items of the current package, without
	 * details. These private items are: constants, variables, functions and
	 * classes. These package-private items cannot be used by other packages,
	 * but still they pollute the namespace, and the documentation must account
	 * for their existance.
	 * @throws IOException 
	 */
	private function docPrivateItems(){
		
		if( count($this->private_constants)
		+ count($this->private_variables)
		+ count($this->private_functions)
		+ count($this->private_classes) == 0 )
			return;
		
		$this->write("<hr><h3>Private items</h3>\n");
		
		if( count($this->private_constants) > 0 ){
			$cs = cast(Constant::class."[int]",
				Arrays::sort($this->private_constants));
			$this->write("<b>Private constants:</b> ");
			for($i = 0; $i < count($cs); $i++){
				if( $i > 0 )  $this->write(",\n");
				$this->write("<code>" . $cs[$i]->name . "</code>");
			}
			$this->write("<br>\n");
			$this->private_constants = NULL;
		}
		
		if( count($this->private_variables) > 0 ){
			$vs = cast(Variable::class."[int]",
				Arrays::sort($this->private_variables));
			$this->write("<b>Private variables:</b> ");
			for($i = 0; $i < count($vs); $i++){
				if( $i > 0 )  $this->write(",\n");
				$this->write("<code>\$" . $vs[$i]->name . "</code>");
			}
			$this->write("<br>\n");
			$this->private_variables = NULL;
		}
		
		if( count($this->private_functions) > 0 ){
			$fs = cast(Function_::class."[int]",
				Arrays::sort($this->private_functions));
			$this->write("<b>Private functions:</b> ");
			for($i = 0; $i < count($fs); $i++){
				if( $i > 0 )  $this->write(",\n");
				$this->write("<code>" . $fs[$i]->name . "()</code>");
			}
			$this->write("<br>\n");
			$this->private_functions = NULL;
		}
		
		if( count($this->private_classes) > 0 ){
			$cls = cast(ClassType::class."[int]",
				Arrays::sort($this->private_classes));
			$this->write("<b>Private classes:</b> ");
			for($i = 0; $i < count($cls); $i++){
				if( $i > 0 )  $this->write(",\n");
				$this->write("<code>" . $cls[$i]->name . "</code>");
			}
			$this->write("<br>\n");
			$this->private_classes = NULL;
		}
		
	}
	

	/**
	 * @param File $fn Package whose HTML file has to be generated.
	 * @return void
	 * @throws IOException Failed writing HTML file.
	 */
	public function generate($fn) {
		$this->relative_path = new RelativePathBuilder($fn, $this->extension, $this->ref_remap);
		$this->in_line_tags = new InLineTags($this->globals, $this->relative_path);
		$this->fn = $fn;
		$html_fn = new File($fn->getBaseName()->append(UString::fromASCII($this->extension)));
		$this->html = new FileOutputStream($html_fn);
		$this->write($this->page_header);
		$this->private_constants = /*.(Constant[int]).*/ array();
		$this->private_variables = /*.(Variable[int]).*/ array();
		$this->private_functions = /*.(Function_[int]).*/ array();
		$this->private_classes = /*.(ClassType[int]).*/ array();
		$this->docHeader();
		$this->docConstants();
		$this->docVariables();
		$this->docFunctions();
		$this->docClasses();
		$this->docPrivateItems();
		$this->docFooter();
		$this->write($this->page_footer);
		$this->html->close();
		$this->html = NULL;
	}

}
