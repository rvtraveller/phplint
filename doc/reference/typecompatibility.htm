<HTML>
<HEAD>
<TITLE>PHPLint Reference Manual</TITLE>
<META name=description content="PHPLint Reference Manual">
<META name=author      content="icosaedro.it di Umberto Salsi">
<META name=owner       content="icosaedro.it di Umberto Salsi">
<META HTTP-EQUIV="Content-Language"    content="en">
<LINK rel=stylesheet type='text/css' href='../styles.css'>
<script type="text/javascript" src="../utils.js"></script>
</HEAD><BODY onload="buildTOC('toc');">

<h2 id="toc">Type compatibility</h2>

<p>
As a general rule, PHPLint does not allow to mix values and variables of
different types.  So, for example, if <code>$i</code> is a variable of type
<b>int</b>, PHPLint expects this variable appears inside an expression that
involves only integer numbers.
</p>

<p>
PHPLint relaxes this strict compatibility rule with some exceptions that are
detailed here. Moreover the chapter <u>Typecasting</u> explains how a value
of given type can be converted into another type in a safe, controlled way.
</p>



<h3>Assignment</h3>

<p>
A <i>right hand side</i> (RHS) is the expression that generates a value,
while a <i>left hand side</i> (LHS) is the entity that stores this value.
The type of the RHS expression is checked against the type expected by
the LHS in these cases:
</p>

<ul>
<li>Assignment instructions: LHS = RHS, LHS += RHS, LHS .= RHS, etc.</li>

<li>Function and method declarations may define a default value (RHS) for
the default formal arguments (LHS).</li>

<li>Calling a function or a method:<p>

	<ul>
	<li>if the actual argument is passed by value (the default) its type
	    is the RHS and the type of the formal argument is the LHS;
	</li>

	<li>if the actual argument is passed by reference or returns by reference,
		that is the formal argument has the attribute "&amp;", then its
	    type is the LHS and the type of the formal argument is the RHS.
	</li>

	</ul>
</li>

<li>Initial value (RHS) of a class property (LHS).</li>

<li>The value generated by the instruction <code>return RHS;</code> is checked
against the function type (LHS).</li>
</ul>

<p>
The table below summarizes the rules PHPLint applies when a value of the
type RHS is assigned (passed by value, etc.) to a variable of the type LHS:
</p>

<pre>

</pre>
<center>
<table border=1 cellspacing=0 cellpadding=3>

<tr>
<td colspan=2 rowspan=2>&nbsp;</td>
<th colspan=10 bgcolor="#ddddff">R H S</th>
</tr>

<tr bgcolor=ccccff>
<th>(null)</th>
<th>void</th>
<th>boolean</th>
<th>&nbsp;&nbsp;int&nbsp;&nbsp;</th>
<th>float</th>
<th>string</th>
<th>array</th>
<th>mixed</th>
<th>resource</th>
<th>(class)</th>
</tr>

<tr>
<th rowspan=10 bgcolor="#ddddff">L<p>H<p>S</th>
<th bgcolor="#ccccff">(null)</th>
<td bgcolor="#aaffaa">-</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
</tr>

<tr>
<th bgcolor="#ccccff">void</th>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
</tr>

<tr>
<th bgcolor="#ccccff">boolean</th>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#aaffaa">-</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffffaa">T</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
</tr>

<tr>
<th bgcolor="#ccccff">int</th>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#aaffaa">-</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffffaa">T</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
</tr>

<tr>
<th bgcolor="#ccccff">float</th>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#aaffaa">-</td>
<td bgcolor="#aaffaa">-</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffffaa">T</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
</tr>

<tr>
<th bgcolor="#ccccff">string</th>
<td bgcolor="#aaffaa">-</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#aaffaa">-</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffffaa">T</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
</tr>

<tr>
<th bgcolor="#ccccff">array</th>
<td bgcolor="#aaffaa">-</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffffaa">A</td>
<td bgcolor="#ffffaa">T</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
</tr>

<tr>
<th bgcolor="#ccccff">mixed</th>
<td bgcolor="#aaffaa">B</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#aaffaa">B</td>
<td bgcolor="#aaffaa">B</td>
<td bgcolor="#aaffaa">B</td>
<td bgcolor="#aaffaa">B</td>
<td bgcolor="#aaffaa">B</td>
<td bgcolor="#aaffaa">-</td>
<td bgcolor="#aaffaa">B</td>
<td bgcolor="#aaffaa">B</td>
</tr>

<tr>
<th bgcolor="#ccccff">resource</th>
<td bgcolor="#aaffaa">-</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffffaa">T</td>
<td bgcolor="#aaffaa">-</td>
<td bgcolor="#ffaaaa">E</td>
</tr>

<tr>
<th bgcolor="#ccccff">(class)</th>
<td bgcolor="#aaffaa">-</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffffaa">T</td>
<td bgcolor="#ffaaaa">E</td>
<td bgcolor="#ffffaa">C</td>
</tr>

</table>
</center>



<pre>

</pre>

<p>
LEGEND:<br>
E = Raises an error message.<br>
T = Required value-conversion operator (example: <code>(int)</code>)
or formal type-cast with the magic function <code>cast(T,V)</code>.<br>
A = Two arrays E[K] are assignment-compatible if the type of the index K and
the type of the elements E are assignment-compatible. See ch. about arrays
for details.<br>
B = Boxing: specific type gets boxed in a mixed type.<br>
C = The RHS must be an object of the same class of the LHS, or a class
derived from the the same class of the LHS, otherwise an error message
is raised.<br>
</p>



<h3>Comparison operators</h3>

<p>
All the comparison operators <code>&lt; &lt;= == &gt;= &gt;</code>
generate a boolean value. For the sake of brevity, we will call the
operators <code>==</code> and <code>!=</code> <i>equality operators</i>.
The PHP language applies some really complex rules and automatic conversions
to the values being compared. For example:
</p>

<blockquote>
<code>"123" == 123</code> is <code>TRUE</code> because the string is
automatically converted into an integer number;<br>
<code>NULL == ""</code> is <code>TRUE</code> because the <code>NULL</code>
value is equivalent to the empty string;<br>
<code>array() == NULL</code> is <code>TRUE</code>;<br>
<code>0.57 - 0.56 == 0.1</code> is <code>FALSE</code>.
</blockquote>

<p>
PHPLint simplifies these rules and forces a more consistent way of handling
the comparisons. In the table below you may think at the first column
as the left term of the comparison, and the second column gives the
types that can appear in the right term of the comparison:
</p>

<pre>

</pre>

<table border=1 cellspacing=0 cellpadding=3>

<tr bgcolor="#ccccff">
<th>Type</th>
<th>Comparison with
<tt>== != &lt; &lt;= &gt;= &gt;</tt>
</th>
</tr>

<tr>
<th valign=top><b>(unknown)</b></th>
<td>
Value of unknown type cannot be compared at all. These values of unknown type
apper when PHPLint was unable to parse successfully the source code.
</td>
</tr>

<tr>
<th valign=top><b>null</b></th>
<td>
The only expression that may generate a value of the type <b>null</b>
is the constant <code>NULL</code>. This value can be compared with other
types as listed below.
</td>
</tr>

<tr>
<th valign=top><b>void</b></th>
<td>
This value returns from functions that... do not return a value,
so it cannot be compared and PHPLint raises an error.
</td>
</tr>

<tr>
<th valign=top><b>boolean</b></th>
<td>
A <b>boolean</b> value can be compared with another <b>boolean</b> value
using the equality operators <code>==</code> and <code>!=</code>.
Any other comparison operator raises an error.
</td>
</tr>

<tr>
<th valign=top><b>int</b></th>
<td>
An <b>int</b> value can be compared with another <b>int</b>.
If you need to compare an integer value versus a floating point number, it is
responsibility of the programmer to convert explicitly the <b>int</b>
into <b>float</b> using the <code>(float)</code> typecast, something like
<code>if( $x &lt; (float) $i ) ...</code>
</td>
</tr>

<tr>
<th valign=top><b>float</b></th>
<td>
A <b>float</b> value can be compared with another <b>float</b> using
the operators <code>&lt; &lt;= &gt;=</code> and <code>&gt;</code>.
Two floating point numbers should not be compared with the equality operators
- see the box below.
Remember also that floating point numbers in the IEEE 754 format can also be
NAN or INF or -INF that must be compared with caution. In particular NAN != NAN
and NAN != from any float, so you must use <code>is_nan()</code> to check for
this value; moreover also INF != INF and INF != from any float so you must use
<code>is_infinite()</code> to check for INF and -INF. See also
<code>is_finite()</code>.
</td>
</tr>

<tr>
<th valign=top><b>string</b></th>
<td>
Strings cannot be compared at all. Either use a strict comparison operator
(see the next paragraph) or the function <code>strcmp()</code>.  See the
chapter <u>How To...</u> for some examples on how to translate an unsafe
string comparison into a PHPLint-compliant safe string comparison.
</td>
</tr>

<tr>
<th valign=top><b>array</b></th>
<td>
Arrays cannot be compared at all. See the next paragraph about the
strict equality operators.
</td>
</tr>

<tr>
<th valign=top><b>mixed</b></th>
<td>
A value of type mixed cannot be compared. Typically mixed values come
from predefined superglobal variables or standard functions that might
return values of different types: always check the actual type of
the value and apply the proper type-cast before the comparison.
</td>
</tr>

<tr>
<th valign=top><b>resource</b></th>
<td>
A <b>resource</b> can be compared with another <b>resource</b> or
with the <code>NULL</code> value using the equality operators.
</td>
</tr>

<tr>
<th valign=top><b>object</b><br><b>(class)</b></th>
<td>
An object can be compared with the <code>NULL</code> value using an equality
operator. Two objects cannot be compared with weak operators. See the next
paragraph about the strict equality operators.
</td>
</tr>

</table>

<pre>

</pre>


<div class="note_box">
<b>Warning</b><br>
Floating point numbers should not be used as "bigger integers with decimals".
Instead they are numbers with high range of values, but limited precision.
The precision cannot be controlled in an effective way, so that simple
calculations might give unpredictable results. For example, this logical
expression gives <code>FALSE</code>:
<p>
<code>0.57 - 0.56 == 0.01</code>
<p>
Do not use floating point numbers to store currency values that might be
fractional, like euro-cents or dollar-cents because their limited precision
can cause rounding errors and other unexpected results.
Please read carefully the manual page
<a href="http://www.php.net/manual/en/language.types.float.php">www.php.net/manual/en/language.types.float.php</a>.
</div>





<h3>Strict equality operators</h3>

<p>
The operator of strict equality <code>===</code> gives <code>TRUE</code>
if and only if the operands are both of the same type and have the
"same value".  If the two operands are of the same type, the "same value"
concept may be expressed as follows:
</p>

<pre>

</pre>

<table border=1 cellspacing=0 cellpadding=3>

<tr bgcolor="#ccccff">
<th>Type</th>
<th>Comparison with === (negate the sentence for !==)</th>
</tr>

<tr>
<th valign=top>boolean</th>
<td>
Gives <code>TRUE</code> if the operands are both <code>FALSE</code> or both <code>TRUE</code>.
</td>
</tr>

<tr>
<th valign=top>int</th>
<td>
Gives <code>TRUE</code> if the two integer numbers are equal.
</td>
</tr>

<tr>
<th valign=top>float</th>
<td>
Gives <code>TRUE</code> if the two floating point numbers are equal. Floating
point numbers in the IEEE 754 format can also be NAN or INF or -INF that must
be compared with caution. In particular NAN !== NAN and NAN != from any float,
so you must use <code>is_nan()</code> to check for this value. On the contrary,
for some obscure reason, under PHP INF === INF.
</td>
</tr>

<tr>
<th valign=top>string</th>
<td>
Gives <code>TRUE</code> if the two strings are both <code>NULL</code>
or they contain the same sequence of bytes. For example, <code>"abc" ===
"ab"."c"</code> gives <code>TRUE</code>.
</td>
</tr>

<tr>
<th valign=top>array</th>
<td>
Gives <code>TRUE</code> if both the arrays are <code>NULL</code> or
they contain the same index/value pairs in the same order, element by
element; the index/value pairs are compared with the strict equality
operator itself.  For example, <code>array(0, 1, 2) === array(0, 1,
2)</code> gives <code>TRUE</code> because the arrays both contains
the same index/value pairs in the same order.  Instead, the comparison
<code>array(0, 1, 2) === array(0=&gt;0, 2=&gt;2, 1=&gt;1)</code> gives
<code>FALSE</code> because, although the index/value pairs are exactly the same,
the elements are stored in memory in a different internal order.
</td>
</tr>

<tr>
<th valign=top>mixed</th>
<td>
The result depends on the type of the two operands, and can be computed
only at run-time.
</td>
</tr>

<tr>
<th valign=top>resource</th>
<td>
Gives <code>TRUE</code> if the two operands are both <code>NULL</code>
or are the same resource.  For example, <code>fopen("xyz", "r") ===
fopen("xyz", "r")</code> gives <code>FALSE</code> because each call to the
<code>fopen()</code> function returns a different file handle.
</td>
</tr>

<tr>
<th valign=top>object<br>(class)</th>
<td>
Gives <code>TRUE</code> if the two operands are both <code>NULL</code> or
are the same object.  Note that <code>new ACLASS() === new ACLASS()</code>
always gives <code>FALSE</code> because the operands are two different
instances of the class "ACLASS".
</td>
</tr>

</table>


<pre>

</pre>

<p>
The operator of strict inequality <code>!==</code> just gives the logical
negation of the strict equality operator <code>===</code>: the result
is <code>TRUE</code> only if the two operands are of different types or
of different values.
</p>

<p>
Some functions of the standard library are formally declared to return
a value of a given type, but in some cases they can return values of
different type too.  For example, the function <code>fopen()</code>
normally returns a value of the type <b>resource</b> if the file was
opened successfully, but the same function returns the <b>boolean</b>
value <code>FALSE</code> when an error occurs. Here is the correct way
to check for such error:
</p>

<div class="code_box">
<pre>$f = @fopen($fn, "r");
if( $f === FALSE )
    die("fopen($fn, r): $php_errormsg");
</pre></div>

<p>
Note that we cannot use the simple equality operator <code>==</code>
since PHPLint would raise an error message because the two operands are of
different types (<code>$f</code> is a <b>resource</b>, <code>FALSE</code>
is a <b>boolean</b> value).
</p>

</body>
</html>
